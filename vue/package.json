{
  "name": "final-vue-capstone-seed",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "serve": "vue-cli-service serve",
    "build": "vue-cli-service build",
    "lint": "vue-cli-service lint"
  },
  "dependencies": {
    "@firebase/storage": "^0.11.2",
    "axios": "^0.21.1",
    "core-js": "^3.9.1",
    "cors": "^2.8.5",
    "express": "^4.18.2",
    "node-fetch": "^3.3.2",
    "vue": "^2.6.12",
    "vue-router": "^3.5.1",
    "vuex": "^3.6.2"
  },
  "devDependencies": {
    "@babel/eslint-parser": "^7.19.1",
    "@vue/babel-preset-app": "^5.0.8",
    "@vue/cli-plugin-babel": "^5.0.8",
    "@vue/cli-plugin-eslint": "^5.0.8",
    "@vue/cli-service": "^5.0.8",
    "@vue/test-utils": "1.1.3",
    "eslint": "^8.26.0",
    "eslint-plugin-vue": "^7.7.0",
    "vue-loader-v16": "npm:vue-loader@16.1.2",
    "vue-template-compiler": "^2.6.12"
  },
  "description": "​\r This is the Vue starter project for the final capstone. This document walks you through how to set up and run the project. It also explains the project's features, such as Vue Router, Vuex, and authentication.\r ​\r ## Project setup\r ​\r The first thing you'll need to do is to download any dependencies by running this command:\r ​\r ```\r npm install\r ```\r ​\r Next take a moment to review the `.env` file that's located in the root of the project. You can store environment variables that you want to use throughout your application in this file. When you open it, it'll look like this:\r ​\r ```\r # Java\r VUE_APP_REMOTE_API=http://localhost:9000\r ```\r ​\r *Note:* The Java Spring Boot application is configured to run on port 9000 instead of 8080.\r ​\r Start your Vue application with the following command:\r ​\r ```\r npm run serve\r ```\r ​\r ## Authentication\r ​\r When you first run the project and visit the base URL, you're taken to a login page. This is because the home route `/` is secured by default. If you look in `/src/router/index.js`, you'll see the following code:\r ​\r ```js\r router.beforeEach((to, from, next) => {\r   // Determine if the route requires Authentication\r   const requiresAuth = to.matched.some(x => x.meta.requiresAuth);\r ​\r   // If it does and they are not logged in, send the user to \"/login\"\r   if (requiresAuth && store.state.token === '') {\r     next(\"/login\");\r   } else {\r     // Else let them go to their next destination\r     next();\r   }\r });\r ```\r ​\r This is a feature of Vue Router called [Navigation Guards](https://router.vuejs.org/guide/advanced/navigation-guards.html). You may not have learned about this in class, so take some time to read through the documentation to learn what they are and how they work.\r ​\r The above code runs before each route. It first checks to see if the route requires authentication that is defined per route using the meta object key `requiresAuth`.\r ​\r In the following configuration, you must be authenticated to view the home route while anyone can visit the login, logout, and registration routes:\r ​\r ```js\r const router = new Router({\r   mode: 'history',\r   base: process.env.BASE_URL,\r   routes: [\r     {\r       path: '/',\r       name: 'home',\r       component: Home,\r       meta: {\r         requiresAuth: true\r       }\r     },\r     {\r       path: \"/login\",\r       name: \"login\",\r       component: Login,\r       meta: {\r         requiresAuth: false\r       }\r     },\r     {\r       path: \"/logout\",\r       name: \"logout\",\r       component: Logout,\r       meta: {\r         requiresAuth: false\r       }\r     },\r     {\r       path: \"/register\",\r       name: \"register\",\r       component: Register,\r       meta: {\r         requiresAuth: false\r       }\r     },\r   ]\r })\r ```\r ​\r Next, the navigation guard checks to see if the route requires authentication and if an authentication token exists.\r ​\r If authentication is not required, *or* the authentication token does exist—meaning it isn't an empty string—the user is routed to the requested route.\r ​\r However, if authentication is required *and* the authentication token doesn't exist—meaning it's an empty string—the user is redirected to the `/login` route:\r ​\r ```js\r // If it does and they are not logged in, send the user to \"/login\"\r if (requiresAuth && store.state.token === '') {\r   next(\"/login\");\r } else {\r   // Else let them go to their next destination\r   next();\r }\r ```\r > Note: the application stores the current user (if any) and their authentication token in a centralized store using Vuex.\r ​\r ### Vuex\r ​\r The state for this application is stored in `/store/index.js` using Vuex. The state object has two values: token and user. When you log in, the back-end service returns an authentication token along with your user credentials.\r ​\r The authentication token is sent in the `Authorization` header to verify your identify. To persist this token when the application is closed or the page is refreshed, you'll store the token in local storage.\r ​\r The default token either comes from local storage or it is set to an empty string. As you learned in the previous section, if the route requires authentication and this token is empty, it redirects the user to the login page:\r ​\r ```js\r const currentToken = localStorage.getItem('token')\r ​\r export default new Vuex.Store({\r   state: {\r     token: currentToken || '',\r     user: currentUser || {}\r   },\r ```\r ​\r ### Login\r ​\r When you reach the `/login` route, you'll see a bare login page. This is intentional. It's up to you to style this page to fit within your application.\r ​\r When you fill in a username and password and click the \"Sign In\" button, the method `login()` is called. The `login()` method uses the `/src/services/AuthService.js` to send a `POST` request to your API's `/login` route.\r ​\r If you look at `AuthService`, you'll notice that there's no base URL set for Axios:\r ​\r ```js\r import axios from 'axios';\r ​\r export default {\r ​\r   login(user) {\r     return axios.post('/login', user)\r   }\r ​\r }\r ```\r ​\r This is because this value is set in `/src/main.js` and the value comes from the `.env` property file you\r saw earlier:\r ​\r ```js\r axios.defaults.baseURL = process.env.VUE_APP_REMOTE_API;\r ```\r ​\r If you get a successful response (200), it contains the authentication token and user object. You'll set these in Vuex by committing mutations:\r ​\r ```js\r login() {\r   authService\r     .login(this.user)\r     .then(response => {\r       if (response.status == 200) {\r         this.$store.commit(\"SET_AUTH_TOKEN\", response.data.token);\r         this.$store.commit(\"SET_USER\", response.data.user);\r         this.$router.push(\"/\");\r       }\r     })\r }\r ```\r ​\r When you call the `SET_AUTH_TOKEN` mutation, several things happen.\r ​\r First, you set the `state.token` value to what was returned from the API's `/login` method. Next, you store that same value in local storage so that it persists across refreshes. Finally, you set the `Authorization` header in Axios so that every subsequent request contains the token. This way, you don't have to manually do this on every request:\r ​\r ```js\r mutations: {\r   SET_AUTH_TOKEN(state, token) {\r     state.token = token;\r     localStorage.setItem('token', token);\r     axios.defaults.headers.common['Authorization'] = `Bearer ${token}`\r   }\r }\r ```\r ​\r Once the `login()` method finishes updating the store by committing the mutations, it forwards the user back to the homepage. They'll be able to see the homepage because they're authenticated.\r ​\r ### Logout\r ​\r There's a logout link in `App.vue` that forwards the user to the `/logout` route. When the user reaches this route, you'll commit this mutation in the store called `LOGOUT`:\r ​\r ```html\r <template>\r   <h1>Logout</h1>\r </template>\r ​\r <script>\r export default {\r   created() {\r     this.$store.commit(\"LOGOUT\");\r     this.$router.push(\"/login\");\r   }\r };\r </script>\r ```\r ​\r When the mutation is called, the token is removed from local storage, the token and user state are cleared, and the user is redirected back to the homepage. The homepage then forwards the user to the login page because they're no longer logged in:\r ​\r ```js\r mutations: {\r   LOGOUT(state) {\r     localStorage.removeItem('token');\r     localStorage.removeItem('user');\r     state.token = '';\r     state.user = {};\r   }\r }\r ```\r ​\r ### Register\r ​\r When you reach the `/register` route, you'll see a bare registration page. Like the login page, this is intentional. You'll need to style this page to fit within your application.\r ​\r When you fill in a username, password, confirm the password role, and click the \"Create Account\" button, the method `register()` is called. This calls the `register()` method in `/src/services/AuthService.js`. This passes  your user details to your back-end application's REST API to create a new user:\r ​\r ```js\r methods: {\r register() {\r   // ...\r   authService\r     .register(this.user)\r     .then(response => {\r       if (response.status == 201) {\r         this.$router.push({\r           path: \"/login\",\r           query: { registration: \"success\" }\r         });\r       }\r     })\r   // ...\r }\r ```",
  "main": ".eslintrc.js",
  "keywords": [],
  "author": "",
  "license": "ISC"
}
